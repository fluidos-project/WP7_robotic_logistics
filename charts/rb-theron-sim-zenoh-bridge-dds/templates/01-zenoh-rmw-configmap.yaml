---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-{{ .Release.Revision }}-zenoh-config
data:
  zenoh-sessions.config.json: |-
    {
      "mode": "client",
      "connect": {
        "endpoints": [
          "{{ .Values.services.zenoh.proto | lower }}/{{ .Values.services.zenoh.name }}:{{ .Values.services.zenoh.port }}"
        ]
      },
      "listen": {
        "endpoints": [
          "{{ .Values.services.zenoh.proto | lower }}/0.0.0.0:{{ .Values.services.zenoh.port }}"
        ]
      },
      "scouting": {
        "timeout": 3000,
        "delay": 1,
        "multicast": {
          "enabled": false,
          "address": "224.0.0.224:7446",
          "interface": "auto",
          "autoconnect": {
            "router": "",
            "peer": "router|peer"
          },
          "listen": true
        },
        "gossip": {
          "enabled": false,
          "multihop": false,
          "autoconnect": {
            "router": "",
            "peer": "router|peer"
          }
        }
      },
      "timestamping": {
        "enabled": {
          "router": true,
          "peer": true,
          "client": true
        },
        "drop_future_timestamp": false
      },
      "queries_default_timeout": 10000,
      "routing": {
        "router": {
          "peers_failover_brokering": false
        },
        "peer": {
          "mode": "peer_to_peer"
        }
      },
      "transport": {
        "unicast": {
          "accept_timeout": 10000,
          "accept_pending": 100,
          "max_sessions": 1000,
          "max_links": 1,
          "lowlatency": false,
          "qos": {
            "enabled": true
          },
          "compression": {
            "enabled": false
          }
        },
        "link": {
          "tx": {
            "sequence_number_resolution": "32bit",
            "lease": 10000,
            "keep_alive": 4,
            "batch_size": 65535,
            "queue": {
              "size": {
                "control": 1,
                "real_time": 1,
                "interactive_high": 1,
                "interactive_low": 1,
                "data_high": 2,
                "data": 4,
                "data_low": 4,
                "background": 4
              },
              "backoff": 100
            }
          },
          "rx": {
            "buffer_size": 65535,
            "max_message_size": 1073741824
          },
          "tls": {
            "root_ca_certificate": null,
            "server_private_key": null,
            "server_certificate": null,
            "client_auth": false,
            "client_private_key": null,
            "client_certificate": null,
            "server_name_verification": null
          }
        },
        "shared_memory": {
          "enabled": false
        },
        "auth": {
          "usrpwd": {
            "user": null,
            "password": null,
            "dictionary_file": null
          },
          "pubkey": {
            "public_key_pem": null,
            "private_key_pem": null,
            "public_key_file": null,
            "private_key_file": null,
            "key_size": null,
            "known_keys_file": null
          }
        }
      },
      "adminspace": {
        "permissions": {
          "read": true,
          "write": false
        }
      },
      plugins: {
        ros2dds: {
          ////
          //// nodename: A ROS node name to be used by this bridge.
          ////            Default: "zenoh_bridge_ros2dds"
          ////
          // nodename: "zenoh_bridge_ros2dds",

          ////
          //// namespace: A ROS namespace which:
          ////             - is used for the "zenoh_bridge_ros2dds" node itself
          ////             - is added to all discovered interfaces when routed to Zenoh
          ////               (i.e. a "cmd_vel" topic in the robot will be seen as "namespace/cmd_vel" outside the robot)
          ////               Note that this also applies to topics with absolute path such as "/rosout", "/tf" and "/tf_static".
          ////            Default: "/"
          ////
          // namespace: "/",

          ////
          //// domain: The DDS Domain ID. By default set to 0, or to "$ROS_DOMAIN_ID" is this environment variable is defined.
          ////
          // domain: 0,

          ////
          //// ros_localhost_only: If set to true, the DDS discovery and traffic will occur only on the localhost interface (127.0.0.1).
          ////                     By default set to false, unless the "ROS_LOCALHOST_ONLY=1" environment variable is defined.
          ////
          // ros_localhost_only: true,

          ////
          //// shm_enabled: If set to true, the DDS implementation will use Iceoryx shared memory.
          ////              Requires the bridge to be built with the 'dds_shm' feature for this option to valid.
          ////              By default set to false.
          ////
          // shm_enabled: false,

          ////
          //// allow / deny: Specify the lists of ROS 2 interfaces that are allowed or denied to be routed over Zenoh.
          ////               Each element of the lists is a regular expression that must match the full interface name.
          ////               You cannot set both 'allow' and 'deny' in the same configuration.
          ////               If neither 'allow' nor 'deny' are set, all interfaces are allowed.
          ////               Use 'allow' to allow only the specified interfaces. If an interface type is set to an empty list
          ////               or is not specified at all, it means that NO such interface is allowed.
          ////               Use 'deny' to allow all except the specified interfaces. If an interface type is set to an empty list
          ////               or is not specified at all, it means that ALL such interface are allowed.
          // allow: {
          //   publishers: [".*/laser_scan", "/tf", ".*/pose"],
          //   subscribers: [".*/cmd_vel"],
          //   service_servers: [".*/.*_parameters"],
          //   service_clients: [],
          //   action_servers: [".*/rotate_absolute"],
          //   action_clients: [],
          // },
          // deny: {
          //   publishers: ["/rosout", "/parameter_events"],
          //   subscribers: ["/rosout"],
          //   service_servers: [".*/set_parameters"],
          //   service_clients: [".*/set_parameters"],
          //   action_servers: [],
          //   action_clients: [],
          // },

          ////
          //// pub_max_frequencies: Specify a list of maximum frequency of publications routing over zenoh for a set of Publishers.
          ////                      The strings must have the format "<regex>=<float>":
          ////                      - "regex" is a regular expression matching a Publisher interface name
          ////                      - "float" is the maximum frequency in Hertz;
          ////                        if publication rate is higher, downsampling will occur when routing.
          // pub_max_frequencies: [".*/laser_scan=5", "/tf=10"],

          ////
          //// pub_priorities: Specify a list of priorities of publications routing over zenoh for a set of Publishers.
          ////                 In case of high traffic, the publications with higher priorities will overtake
          ////                 the publications with lower priorities in Zenoh publication queues.
          ////                 The strings must have the format "<regex>=<integer>[:express]":
          ////                 - "regex" is a regular expression matching a Publisher topic name
          ////                 - "integer" is a priority value in the range [1-7]. Highest priority is 1, lowest is 7 and default is 5.
          ////                   (see Zenoh Priority definition here: https://docs.rs/zenoh/latest/zenoh/publication/enum.Priority.html)
          ////                - ":express" is an option to indicate that the Zenoh express policy must be used for those publications.
          ////                   The express policy makes Zenoh to to send the message immediatly, not waiting for possible further messages
          ////                   to create a bigger batch of messages. This usually has a positive impact on latency for the topic
          ////                   but a negative impact on the general throughput, as more overhead is used for those topics.
          // pub_priorities: ["/scan=1:express", "/pose=2", "/rosout=7"],

          ////
          //// reliable_routes_blocking: When true, the publications from a RELIABLE DDS Writer will be
          ////                           routed to zenoh using the CongestionControl::Block option.
          ////                           Meaning the routing will be blocked in case of network congestion,
          ////                           blocking the DDS Reader and the RELIABLE DDS Writer in return.
          ////                           When false (or for BERST_EFFORT DDS Writers), CongestionControl::Drop
          ////                           is used, meaning the route might drop some data in case of congestion.
          ////
          // reliable_routes_blocking: true,

          ////
          //// queries_timeout: Timeouts configuration for various Zenoh queries.
          ////                  Each field is optional. If not set, the 'default' timeout (5.0 seconds by default) applies to all queries.
          ////                  Each value can be either a float in seconds that will apply as a timeout to all queries,
          ////                  either a list of strings with format "<regex>=<float>" where:
          ////                      - "regex" is a regular expression matching an interface name
          ////                      - "float" is the timeout in seconds
          // queries_timeout: {
          //   //// default timeout that will apply to all query, except the ones specified below
          //   //// in 'transient_local_subscribers', 'services' and 'actions'
          //   default: 5.0,
          //   //// timeouts for TRANSIENT_LOCAL subscriber when querying publishers for historical publications
          //   transient_local_subscribers: 1.0,
          //   //// timeouts for Service clients calling a Service server
          //   services: ["add_two_ints=0.5", ".*=1.0"],
          //   //// timeouts for Action clients calling an Action server (send_goal, cancel_goal and get_result services)
          //   actions: {
          //     send_goal: 1.0,
          //     cancel_goal: 1.0,
          //     get_result: [".*long_mission=3600", ".*short_action=10.0"],
          //   }
          // },

          ////
          //// This plugin uses Tokio (https://tokio.rs/) for asynchronous programming. 
          //// When running as a plugin within a Zenoh router, the plugin creates its own Runtime managing 2 pools of threads:
          ////    - worker threads for non-blocking tasks. Those threads are spawn at Runtime creation.
          ////    - blocking threads for blocking tasks (e.g. I/O). Those threads are spawn when needed.
          //// For more details see https://github.com/tokio-rs/tokio/discussions/3858#discussioncomment-869878
          //// When running as a standalone bridge the Zenoh Session's Runtime is used and can be configured via the
          //// `ZENOH_RUNTIME` environment variable. See https://docs.rs/zenoh-runtime/latest/zenoh_runtime/enum.ZRuntime.html
          ////
          
          //// work_thread_num: The number of worker thread in the asynchronous runtime will use. (default: 2)
          ////                  Only for a plugin, no effect on a bridge.
          // work_thread_num: 2,
          
          //// max_block_thread_num: The number of blocking thread in the asynchronous runtime will use. (default: 50)
          ////                       Only for a plugin, no effect on a bridge.
          // max_block_thread_num: 50,
        },

        ////
        //// REST API configuration (active only if this part is defined)
        ////
        // rest: {
        //   ////
        //   //// The HTTP port number (for all network interfaces).
        //   //// You can bind on a specific interface setting a "<local_ip>:<port>" string.
        //   ////
        //   http_port: 8000,
        // },
      },

      ////
      //// Zenoh related configuration.
      //// Only the most relevant sections are displayed here.
      //// For a complete view of configuration possibilities, see https://github.com/eclipse-zenoh/zenoh/blob/main/DEFAULT_CONFIG.json5
      ////

      /// The identifier (as unsigned 128bit integer in hexadecimal lowercase - leading zeros are not accepted)
      /// that zenoh runtime will use.
      /// If not set, a random unsigned 128bit integer will be used.
      /// WARNING: this id must be unique in your zenoh network.
      // id: "1234567890abcdef",

      ////
      //// mode: The bridge's mode (router, peer or client)
      ////
      //mode: "router",

      ////
      //// Which endpoints to connect to. E.g. tcp/localhost:7447.
      //// By configuring the endpoints, it is possible to tell zenoh which remote router or other zenoh-bridge-ros2dds to connect to at startup.
      ////
      connect: {
        endpoints: [
          // "<proto>/<ip>:<port>"
        ]
      },

      ////
      //// Which endpoints to listen on.
      //// By configuring the endpoints, it is possible to tell zenoh which are the endpoints that other routers,
      //// peers, or client can use to establish a zenoh session.
      //// In 'router' mode (default) the zenoh-bridge-ros2dds is listening by default on `tcp/0.0.0.0:7447` (`0.0.0.0` meaning all the available network interfaces)
      ////
      // listen: {
      //  endpoints: [
      //    // "<proto>/<ip>:<port>"
      //  ]
      //},

      ////
      //// Configure the scouting mechanisms and their behaviours
      ////
      //scouting: {
      //  /// The UDP multicast scouting configuration.
      //  multicast: {
      //    /// Whether multicast scouting is enabled or not
      //    enabled: true,
      //    /// The socket which should be used for multicast scouting
      //    address: "224.0.0.224:7446",
      //    /// The network interface which should be used for multicast scouting
      //    interface: "auto", // If not set or set to "auto" the interface if picked automatically
      //    /// Which type of Zenoh instances to automatically establish sessions with upon discovery on UDP multicast.
      //    /// Accepts a single value or different values for router, peer and client.
      //    /// Each value is bit-or-like combinations of "peer", "router" and "client".
      //    autoconnect: { router: "", peer: "router|peer" },
      //    /// Whether or not to listen for scout messages on UDP multicast and reply to them.
      //    listen: true,
      //  },
      //  /// The gossip scouting configuration.
      //  gossip: {
      //    /// Whether gossip scouting is enabled or not
      //    enabled: true,
      //    /// When true, gossip scouting information is propagated multiple hops to all nodes in the local network.
      //    /// When false, gossip scouting information is only propagated to the next hop.
      //    /// Activating multihop gossip implies more scouting traffic and a lower scalability.
      //    /// It mostly makes sense when using "linkstate" routing mode where all nodes in the subsystem don't have
      //    /// direct connectivity with each other.
      //    multihop: false,
      //    /// Which type of Zenoh instances to automatically establish sessions with upon discovery on gossip.
      //    /// Accepts a single value or different values for router, peer and client.
      //    /// Each value is bit-or-like combinations of "peer", "router" and "client".
      //    autoconnect: { router: "", peer: "router|peer" },
      //  },
      //},
    }
  zenoh-router.config.json: |-
    {
      "mode": "router",
      "connect": {
        "endpoints": []
      },
      "listen": {
        "endpoints": [
          "{{ .Values.services.zenoh.proto | lower }}/0.0.0.0:{{ .Values.services.zenoh.port }}"
        ]
      },
      "scouting": {
        "timeout": 3000,
        "delay": 1,
        "multicast": {
          "enabled": false,
          "address": "224.0.0.224:7446",
          "interface": "auto",
          "autoconnect": {
            "router": "",
            "peer": "router|peer"
          },
          "listen": true
        },
        "gossip": {
          "enabled": true,
          "multihop": false,
          "autoconnect": {
            "router": "",
            "peer": "router|peer"
          }
        }
      },
      "timestamping": {
        "enabled": {
          "router": true,
          "peer": true,
          "client": true
        },
        "drop_future_timestamp": false
      },
      "queries_default_timeout": 10000,
      "routing": {
        "router": {
          "peers_failover_brokering": false
        },
        "peer": {
          "mode": "peer_to_peer"
        }
      },
      "transport": {
        "unicast": {
          "accept_timeout": 10000,
          "accept_pending": 100,
          "max_sessions": 1000,
          "max_links": 1,
          "lowlatency": false,
          "qos": {
            "enabled": true
          },
          "compression": {
            "enabled": false
          }
        },
        "link": {
          "tx": {
            "sequence_number_resolution": "32bit",
            "lease": 10000,
            "keep_alive": 4,
            "batch_size": 65535,
            "queue": {
              "size": {
                "control": 1,
                "real_time": 1,
                "interactive_high": 1,
                "interactive_low": 1,
                "data_high": 2,
                "data": 4,
                "data_low": 4,
                "background": 4
              },
              "backoff": 100
            }
          },
          "rx": {
            "buffer_size": 65535,
            "max_message_size": 1073741824
          },
          "tls": {
            "root_ca_certificate": null,
            "server_private_key": null,
            "server_certificate": null,
            "client_auth": false,
            "client_private_key": null,
            "client_certificate": null,
            "server_name_verification": null
          }
        },
        "shared_memory": {
          "enabled": false
        },
        "auth": {
          "usrpwd": {
            "user": null,
            "password": null,
            "dictionary_file": null
          },
          "pubkey": {
            "public_key_pem": null,
            "private_key_pem": null,
            "public_key_file": null,
            "private_key_file": null,
            "key_size": null,
            "known_keys_file": null
          }
        }
      },
      "adminspace": {
        "permissions": {
          "read": true,
          "write": false
        }
      }
      "plugins":{
        rest: {
          http_port: 8000,
      },
    }
  # zenoh-sessions.config.json5: |-
  #   /// This file attempts to list and document available configuration elements.
  #   /// For a more complete view of the configuration's structure, check out `zenoh/src/config.rs`'s `Config` structure.
  #   /// Note that the values here are correctly typed, but may not be sensible, so copying this file to change only the parts that matter to you is not good practice.
  #   {
  #     /// The identifier (as unsigned 128bit integer in hexadecimal lowercase - leading zeros are not accepted)
  #     /// that zenoh runtime will use.
  #     /// If not set, a random unsigned 128bit integer will be used.
  #     /// WARNING: this id must be unique in your zenoh network.
  #     // id: "1234567890abcdef",

  #     /// The node's mode (router, peer or client)
  #     mode: "peer",

  #     /// Which endpoints to connect to. E.g. tcp/localhost:7447.
  #     /// By configuring the endpoints, it is possible to tell zenoh which router/peer to connect to at startup.
  #     /// ROS setting: By default connect to the Zenoh router on localhost on port 7447.
  #     connect: {
  #       endpoints: [
  #         "{{ .Values.services.zenoh.proto | lower }}/{{ .Values.services.zenoh.name }}:{{ .Values.services.zenoh.port }}",
  #       ],
  #     },

  #     /// Which endpoints to listen on. E.g. tcp/localhost:7447.
  #     /// By configuring the endpoints, it is possible to tell zenoh which are the endpoints that other routers,
  #     /// peers, or client can use to establish a zenoh session.
  #     /// ROS setting: By default accept incoming connections only from localhost (i.e. from colocalized Nodes).
  #     ///              All communications with other hosts are routed by the Zenoh router.
  #     listen: {
  #       endpoints: [
  #         "tcp/localhost:0",
  #       ],
  #     },
  #     /// Configure the scouting mechanisms and their behaviours
  #     scouting: {
  #       /// In client mode, the period dedicated to scouting for a router before failing
  #       timeout: 3000,
  #       /// In peer mode, the period dedicated to scouting remote peers before attempting other operations
  #       delay: 1,
  #       /// The multicast scouting configuration.
  #       multicast: {
  #         /// Whether multicast scouting is enabled or not
  #         enabled: false,
  #         /// The socket which should be used for multicast scouting
  #         address: "224.0.0.224:7446",
  #         /// The network interface which should be used for multicast scouting
  #         interface: "auto", // If not set or set to "auto" the interface if picked automatically
  #         /// Which type of Zenoh instances to automatically establish sessions with upon discovery on UDP multicast.
  #         /// Accepts a single value or different values for router, peer and client.
  #         /// Each value is bit-or-like combinations of "peer", "router" and "client".
  #         autoconnect: { router: "", peer: "router|peer" },
  #         /// Whether or not to listen for scout messages on UDP multicast and reply to them.
  #         listen: true,
  #       },
  #       /// The gossip scouting configuration.
  #       gossip: {
  #         /// Whether gossip scouting is enabled or not
  #         enabled: true,
  #         /// When true, gossip scouting informations are propagated multiple hops to all nodes in the local network.
  #         /// When false, gossip scouting informations are only propagated to the next hop.
  #         /// Activating multihop gossip implies more scouting traffic and a lower scalability.
  #         /// It mostly makes sense when using "linkstate" routing mode where all nodes in the subsystem don't have
  #         /// direct connectivity with each other.
  #         multihop: false,
  #         /// Which type of Zenoh instances to automatically establish sessions with upon discovery on gossip.
  #         /// Accepts a single value or different values for router, peer and client.
  #         /// Each value is bit-or-like combinations of "peer", "router" and "client".
  #         autoconnect: { router: "", peer: "router|peer" },
  #       },
  #     },

  #     /// Configuration of data messages timestamps management.
  #     timestamping: {
  #       /// Whether data messages should be timestamped if not already.
  #       /// Accepts a single boolean value or different values for router, peer and client.
  #       /// PublicationCache which is required for transient_local durability
  #       /// only works when time-stamping is enabled.
  #       enabled: { router: true, peer: true, client: false },
  #       /// Whether data messages with timestamps in the future should be dropped or not.
  #       /// If set to false (default), messages with timestamps in the future are retimestamped.
  #       /// Timestamps are ignored if timestamping is disabled.
  #       drop_future_timestamp: false,
  #     },

  #     /// The default timeout to apply to queries in milliseconds.
  #     queries_default_timeout: 10000,

  #     /// The routing strategy to use and it's configuration.
  #     routing: {
  #       /// The routing strategy to use in routers and it's configuration.
  #       router: {
  #         /// When set to true a router will forward data between two peers
  #         /// directly connected to it if it detects that those peers are not
  #         /// connected to each other.
  #         /// The failover brokering only works if gossip discovery is enabled.
  #         peers_failover_brokering: true,
  #       },
  #       /// The routing strategy to use in peers and it's configuration.
  #       peer: {
  #         /// The routing strategy to use in peers. ("peer_to_peer" or "linkstate").
  #         mode: "peer_to_peer",
  #       },
  #     },

  #     //  /// The declarations aggregation strategy.
  #     //  aggregation: {
  #     //      /// A list of key-expressions for which all included subscribers will be aggregated into.
  #     //      subscribers: [
  #     //        // key_expression
  #     //      ],
  #     //      /// A list of key-expressions for which all included publishers will be aggregated into.
  #     //      publishers: [
  #     //        // key_expression
  #     //      ],
  #     //  },

  #    /// Configure internal transport parameters
  #     transport: {
  #       unicast: {
  #         /// Timeout in milliseconds when opening a link
  #         accept_timeout: 10000,
  #         /// Maximum number of zenoh session in pending state while accepting
  #         accept_pending: 100,
  #         /// Maximum number of sessions that can be simultaneously alive
  #         max_sessions: 1000,
  #         /// Maximum number of incoming links that are admitted per session
  #         max_links: 1,
  #         /// Enables the LowLatency transport
  #         /// This option does not make LowLatency transport mandatory, the actual implementation of transport
  #         /// used will depend on Establish procedure and other party's settings
  #         ///
  #         /// NOTE: Currently, the LowLatency transport doesn't preserve QoS prioritization.
  #         /// NOTE: Due to the note above, 'lowlatency' is incompatible with 'qos' option, so in order to
  #         ///       enable 'lowlatency' you need to explicitly disable 'qos'.
  #         lowlatency: false,
  #         /// Enables QoS on unicast communications.
  #         qos: {
  #           enabled: true,
  #         },
  #         /// Enables compression on unicast communications.
  #         /// Compression capabilities are negotiated during session establishment.
  #         /// If both Zenoh nodes support compression, then compression is activated.
  #         compression: {
  #           enabled: false,
  #         },
  #       },
  #       link: {
  #         /// An optional whitelist of protocols to be used for accepting and opening sessions.
  #         /// If not configured, all the supported protocols are automatically whitelisted.
  #         /// The supported protocols are: ["tcp" , "udp", "tls", "quic", "ws", "unixsock-stream"]
  #         /// For example, to only enable "tls" and "quic":
  #         //   protocols: ["tls", "quic"],
  #         /// Configure the zenoh TX parameters of a link
  #         tx: {
  #           /// The resolution in bits to be used for the message sequence numbers.
  #           /// When establishing a session with another Zenoh instance, the lowest value of the two instances will be used.
  #           /// Accepted values: 8bit, 16bit, 32bit, 64bit.
  #           sequence_number_resolution: "32bit",
  #           /// Link lease duration in milliseconds to announce to other zenoh nodes
  #           lease: 10000,
  #           /// Number of keep-alive messages in a link lease duration. If no data is sent, keep alive
  #           /// messages will be sent at the configured time interval.
  #           /// NOTE: In order to consider eventual packet loss and transmission latency and jitter,
  #           ///       set the actual keep_alive timeout to one fourth of the lease time.
  #           ///       This is in-line with the ITU-T G.8013/Y.1731 specification on continous connectivity
  #           ///       check which considers a link as failed when no messages are received in 3.5 times the
  #           ///       target interval.
  #           keep_alive: 4,
  #           /// Batch size in bytes is expressed as a 16bit unsigned integer.
  #           /// Therefore, the maximum batch size is 2^16-1 (i.e. 65535).
  #           /// The default batch size value is the maximum batch size: 65535.
  #           batch_size: 65535,
  #           /// Each zenoh link has a transmission queue that can be configured
  #           queue: {
  #             /// The size of each priority queue indicates the number of batches a given queue can contain.
  #             /// The amount of memory being allocated for each queue is then SIZE_XXX * BATCH_SIZE.
  #             /// In the case of the transport link MTU being smaller than the ZN_BATCH_SIZE,
  #             /// then amount of memory being allocated for each queue is SIZE_XXX * LINK_MTU.
  #             /// If qos is false, then only the DATA priority will be allocated.
  #             size: {
  #               control: 1,
  #               real_time: 1,
  #               interactive_high: 1,
  #               interactive_low: 1,
  #               data_high: 2,
  #               data: 4,
  #               data_low: 4,
  #               background: 4,
  #             },
  #             /// The initial exponential backoff time in nanoseconds to allow the batching to eventually progress.
  #             /// Higher values lead to a more aggressive batching but it will introduce additional latency.
  #             backoff: 100,
  #           },
  #           // Number of threads dedicated to transmission
  #           // By default, the number of threads is calculated as follows: 1 + ((#cores - 1) / 4)
  #           // threads: 1,
  #         },
  #         /// Configure the zenoh RX parameters of a link
  #         rx: {
  #           /// Receiving buffer size in bytes for each link
  #           /// The default the rx_buffer_size value is the same as the default batch size: 65335.
  #           /// For very high throughput scenarios, the rx_buffer_size can be increased to accomodate
  #           /// more in-flight data. This is particularly relevant when dealing with large messages.
  #           /// E.g. for 16MiB rx_buffer_size set the value to: 16777216.
  #           buffer_size: 65535,
  #           /// Maximum size of the defragmentation buffer at receiver end.
  #           /// Fragmented messages that are larger than the configured size will be dropped.
  #           /// The default value is 1GiB. This would work in most scenarios.
  #           /// NOTE: reduce the value if you are operating on a memory constrained device.
  #           max_message_size: 1073741824,
  #         },
  #         /// Configure TLS specific parameters
  #         tls: {
  #           /// Path to the certificate of the certificate authority used to validate either the server
  #           /// or the client's keys and certificates, depending on the node's mode. If not specified
  #           /// on router mode then the default WebPKI certificates are used instead.
  #           root_ca_certificate: null,
  #           /// Path to the TLS server private key
  #           server_private_key: null,
  #           /// Path to the TLS server public certificate
  #           server_certificate: null,
  #           /// Client authentication, if true enables mTLS (mutual authentication)
  #           client_auth: false,
  #           /// Path to the TLS client private key
  #           client_private_key: null,
  #           /// Path to the TLS client public certificate
  #           client_certificate: null,
  #           // Whether or not to use server name verification, if set to false zenoh will disregard the common names of the certificates when verifying servers.
  #           // This could be dangerous because your CA can have signed a server cert for foo.com, that's later being used to host a server at baz.com. If you wan't your
  #           // ca to verify that the server at baz.com is actually baz.com, let this be true (default).
  #           server_name_verification: null,
  #         },
  #       },
  #       /// Shared memory configuration
  #       shared_memory: {
  #         enabled: false,
  #       },
  #       /// Access control configuration
  #       auth: {
  #         /// The configuration of authentification.
  #         /// A password implies a username is required.
  #         usrpwd: {
  #           user: null,
  #           password: null,
  #           /// The path to a file containing the user password dictionary
  #           dictionary_file: null,
  #         },
  #         pubkey: {
  #           public_key_pem: null,
  #           private_key_pem: null,
  #           public_key_file: null,
  #           private_key_file: null,
  #           key_size: null,
  #           known_keys_file: null,
  #         },
  #       },
  #     },

  #     /// Configure the Admin Space
  #     /// Unstable: this configuration part works as advertised, but may change in a future release
  #     adminspace: {
  #       // read and/or write permissions on the admin space
  #       permissions: {
  #         read: true,
  #         write: false,
  #       },
  #     },
  #   }
  # zenoh-router.config.json5: |-
  #   /// This file attempts to list and document available configuration elements.
  #   /// For a more complete view of the configuration's structure, check out `zenoh/src/config.rs`'s `Config` structure.
  #   /// Note that the values here are correctly typed, but may not be sensible, so copying this file to change only the parts that matter to you is not good practice.
  #   {
  #     /// The identifier (as unsigned 128bit integer in hexadecimal lowercase - leading zeros are not accepted)
  #     /// that zenoh runtime will use.
  #     /// If not set, a random unsigned 128bit integer will be used.
  #     /// WARNING: this id must be unique in your zenoh network.
  #     // id: "1234567890abcdef",

  #     /// The node's mode (router, peer or client)
  #     mode: "router",

  #     /// Which endpoints to connect to. E.g. tcp/localhost:7447.
  #     /// By configuring the endpoints, it is possible to tell zenoh which router/peer to connect to at startup.
  #     connect: {
  #       endpoints: [
  #         // "<proto>/<address>"
  #       ],
  #     },

  #     /// Which endpoints to listen on. E.g. tcp/localhost:7447.
  #     /// By configuring the endpoints, it is possible to tell zenoh which are the endpoints that other routers,
  #     /// peers, or client can use to establish a zenoh session.
  #     listen: {
  #       endpoints: [
  #         "{{ .Values.services.zenoh.proto | lower }}/[::]:{{ .Values.services.zenoh.port }}"
  #       ],
  #     },
  #     /// Configure the scouting mechanisms and their behaviours
  #     scouting: {
  #       /// In client mode, the period dedicated to scouting for a router before failing
  #       timeout: 3000,
  #       /// In peer mode, the period dedicated to scouting remote peers before attempting other operations
  #       delay: 1,
  #       /// The multicast scouting configuration.
  #       multicast: {
  #         /// Whether multicast scouting is enabled or not
  #         enabled: false,
  #         /// The socket which should be used for multicast scouting
  #         address: "224.0.0.224:7446",
  #         /// The network interface which should be used for multicast scouting
  #         interface: "auto", // If not set or set to "auto" the interface if picked automatically
  #         /// Which type of Zenoh instances to automatically establish sessions with upon discovery on UDP multicast.
  #         /// Accepts a single value or different values for router, peer and client.
  #         /// Each value is bit-or-like combinations of "peer", "router" and "client".
  #         autoconnect: { router: "", peer: "router|peer" },
  #         /// Whether or not to listen for scout messages on UDP multicast and reply to them.
  #         listen: true,
  #       },
  #       /// The gossip scouting configuration.
  #       gossip: {
  #         /// Whether gossip scouting is enabled or not
  #         enabled: true,
  #         /// When true, gossip scouting informations are propagated multiple hops to all nodes in the local network.
  #         /// When false, gossip scouting informations are only propagated to the next hop.
  #         /// Activating multihop gossip implies more scouting traffic and a lower scalability.
  #         /// It mostly makes sense when using "linkstate" routing mode where all nodes in the subsystem don't have
  #         /// direct connectivity with each other.
  #         multihop: false,
  #         /// Which type of Zenoh instances to automatically establish sessions with upon discovery on gossip.
  #         /// Accepts a single value or different values for router, peer and client.
  #         /// Each value is bit-or-like combinations of "peer", "router" and "client".
  #         autoconnect: { router: "", peer: "router|peer" },
  #       },
  #     },

  #     /// Configuration of data messages timestamps management.
  #     timestamping: {
  #       /// Whether data messages should be timestamped if not already.
  #       /// Accepts a single boolean value or different values for router, peer and client.
  #       /// PublicationCache which is required for transient_local durability
  #       /// only works when time-stamping is enabled.
  #       enabled: { router: true, peer: true, client: false },
  #       /// Whether data messages with timestamps in the future should be dropped or not.
  #       /// If set to false (default), messages with timestamps in the future are retimestamped.
  #       /// Timestamps are ignored if timestamping is disabled.
  #       drop_future_timestamp: false,
  #     },

  #     /// The default timeout to apply to queries in milliseconds.
  #     queries_default_timeout: 10000,

  #     /// The routing strategy to use and it's configuration.
  #     routing: {
  #       /// The routing strategy to use in routers and it's configuration.
  #       router: {
  #         /// When set to true a router will forward data between two peers
  #         /// directly connected to it if it detects that those peers are not
  #         /// connected to each other.
  #         /// The failover brokering only works if gossip discovery is enabled.
  #         peers_failover_brokering: true,
  #       },
  #       /// The routing strategy to use in peers and it's configuration.
  #       peer: {
  #         /// The routing strategy to use in peers. ("peer_to_peer" or "linkstate").
  #         mode: "peer_to_peer",
  #       },
  #     },

  #     //  /// The declarations aggregation strategy.
  #     //  aggregation: {
  #     //      /// A list of key-expressions for which all included subscribers will be aggregated into.
  #     //      subscribers: [
  #     //        // key_expression
  #     //      ],
  #     //      /// A list of key-expressions for which all included publishers will be aggregated into.
  #     //      publishers: [
  #     //        // key_expression
  #     //      ],
  #     //  },

  #    /// Configure internal transport parameters
  #     transport: {
  #       unicast: {
  #         /// Timeout in milliseconds when opening a link
  #         accept_timeout: 10000,
  #         /// Maximum number of zenoh session in pending state while accepting
  #         accept_pending: 100,
  #         /// Maximum number of sessions that can be simultaneously alive
  #         max_sessions: 1000,
  #         /// Maximum number of incoming links that are admitted per session
  #         max_links: 1,
  #         /// Enables the LowLatency transport
  #         /// This option does not make LowLatency transport mandatory, the actual implementation of transport
  #         /// used will depend on Establish procedure and other party's settings
  #         ///
  #         /// NOTE: Currently, the LowLatency transport doesn't preserve QoS prioritization.
  #         /// NOTE: Due to the note above, 'lowlatency' is incompatible with 'qos' option, so in order to
  #         ///       enable 'lowlatency' you need to explicitly disable 'qos'.
  #         lowlatency: false,
  #         /// Enables QoS on unicast communications.
  #         qos: {
  #           enabled: true,
  #         },
  #         /// Enables compression on unicast communications.
  #         /// Compression capabilities are negotiated during session establishment.
  #         /// If both Zenoh nodes support compression, then compression is activated.
  #         compression: {
  #           enabled: false,
  #         },
  #       },
  #       link: {
  #         /// An optional whitelist of protocols to be used for accepting and opening sessions.
  #         /// If not configured, all the supported protocols are automatically whitelisted.
  #         /// The supported protocols are: ["tcp" , "udp", "tls", "quic", "ws", "unixsock-stream"]
  #         /// For example, to only enable "tls" and "quic":
  #         //   protocols: ["tls", "quic"],
  #         /// Configure the zenoh TX parameters of a link
  #         tx: {
  #           /// The resolution in bits to be used for the message sequence numbers.
  #           /// When establishing a session with another Zenoh instance, the lowest value of the two instances will be used.
  #           /// Accepted values: 8bit, 16bit, 32bit, 64bit.
  #           sequence_number_resolution: "32bit",
  #           /// Link lease duration in milliseconds to announce to other zenoh nodes
  #           lease: 10000,
  #           /// Number of keep-alive messages in a link lease duration. If no data is sent, keep alive
  #           /// messages will be sent at the configured time interval.
  #           /// NOTE: In order to consider eventual packet loss and transmission latency and jitter,
  #           ///       set the actual keep_alive timeout to one fourth of the lease time.
  #           ///       This is in-line with the ITU-T G.8013/Y.1731 specification on continous connectivity
  #           ///       check which considers a link as failed when no messages are received in 3.5 times the
  #           ///       target interval.
  #           keep_alive: 4,
  #           /// Batch size in bytes is expressed as a 16bit unsigned integer.
  #           /// Therefore, the maximum batch size is 2^16-1 (i.e. 65535).
  #           /// The default batch size value is the maximum batch size: 65535.
  #           batch_size: 65535,
  #           /// Each zenoh link has a transmission queue that can be configured
  #           queue: {
  #             /// The size of each priority queue indicates the number of batches a given queue can contain.
  #             /// The amount of memory being allocated for each queue is then SIZE_XXX * BATCH_SIZE.
  #             /// In the case of the transport link MTU being smaller than the ZN_BATCH_SIZE,
  #             /// then amount of memory being allocated for each queue is SIZE_XXX * LINK_MTU.
  #             /// If qos is false, then only the DATA priority will be allocated.
  #             size: {
  #               control: 1,
  #               real_time: 1,
  #               interactive_high: 1,
  #               interactive_low: 1,
  #               data_high: 2,
  #               data: 4,
  #               data_low: 4,
  #               background: 4,
  #             },
  #             /// The initial exponential backoff time in nanoseconds to allow the batching to eventually progress.
  #             /// Higher values lead to a more aggressive batching but it will introduce additional latency.
  #             backoff: 100,
  #           },
  #           // Number of threads dedicated to transmission
  #           // By default, the number of threads is calculated as follows: 1 + ((#cores - 1) / 4)
  #           // threads: 1,
  #         },
  #         /// Configure the zenoh RX parameters of a link
  #         rx: {
  #           /// Receiving buffer size in bytes for each link
  #           /// The default the rx_buffer_size value is the same as the default batch size: 65335.
  #           /// For very high throughput scenarios, the rx_buffer_size can be increased to accomodate
  #           /// more in-flight data. This is particularly relevant when dealing with large messages.
  #           /// E.g. for 16MiB rx_buffer_size set the value to: 16777216.
  #           buffer_size: 65535,
  #           /// Maximum size of the defragmentation buffer at receiver end.
  #           /// Fragmented messages that are larger than the configured size will be dropped.
  #           /// The default value is 1GiB. This would work in most scenarios.
  #           /// NOTE: reduce the value if you are operating on a memory constrained device.
  #           max_message_size: 1073741824,
  #         },
  #         /// Configure TLS specific parameters
  #         tls: {
  #           /// Path to the certificate of the certificate authority used to validate either the server
  #           /// or the client's keys and certificates, depending on the node's mode. If not specified
  #           /// on router mode then the default WebPKI certificates are used instead.
  #           root_ca_certificate: null,
  #           /// Path to the TLS server private key
  #           server_private_key: null,
  #           /// Path to the TLS server public certificate
  #           server_certificate: null,
  #           /// Client authentication, if true enables mTLS (mutual authentication)
  #           client_auth: false,
  #           /// Path to the TLS client private key
  #           client_private_key: null,
  #           /// Path to the TLS client public certificate
  #           client_certificate: null,
  #           // Whether or not to use server name verification, if set to false zenoh will disregard the common names of the certificates when verifying servers.
  #           // This could be dangerous because your CA can have signed a server cert for foo.com, that's later being used to host a server at baz.com. If you wan't your
  #           // ca to verify that the server at baz.com is actually baz.com, let this be true (default).
  #           server_name_verification: null,
  #         },
  #       },
  #       /// Shared memory configuration
  #       shared_memory: {
  #         enabled: false,
  #       },
  #       /// Access control configuration
  #       auth: {
  #         /// The configuration of authentification.
  #         /// A password implies a username is required.
  #         usrpwd: {
  #           user: null,
  #           password: null,
  #           /// The path to a file containing the user password dictionary
  #           dictionary_file: null,
  #         },
  #         pubkey: {
  #           public_key_pem: null,
  #           private_key_pem: null,
  #           public_key_file: null,
  #           private_key_file: null,
  #           key_size: null,
  #           known_keys_file: null,
  #         },
  #       },
  #     },

  #     /// Configure the Admin Space
  #     /// Unstable: this configuration part works as advertised, but may change in a future release
  #     adminspace: {
  #       // read and/or write permissions on the admin space
  #       permissions: {
  #         read: true,
  #         write: false,
  #       },
  #     },

  #   }

